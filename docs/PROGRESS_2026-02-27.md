# Echo Project Progress — Background Dictation Implementation (2026-02-27)

## TL;DR

本次 session 完成了 iOS 后台录音 + 键盘实时注入的核心实现（Plan Phase 1-3），功能已部分可用但存在一个关键 bug 待修。

**已完成:**
1. Phase 1: 核心基础设施 — DarwinNotificationCenter、AppGroupBridge streaming IPC、ASRProviderResolver、BackgroundDictationService
2. Phase 2: 主 App 集成 — BackgroundDictationOverlay 浮层、环境对象注入、deep link 路由
3. Phase 3: 键盘扩展 — 条件 voice 按钮（Darwin toggle vs Link）、增量文字注入、心跳检查
4. 多次 bug fix: AVAudioSession 冲突、构建错误、DerivedData 路径问题

**当前状态: 首次录音可用，再次录音失败**

**待修 Bug (CRITICAL):**
> 点击键盘录音键 → 跳转到 App → 看到录音开始 → 手动切回输入框 → 键盘显示录音状态 → 实时转译正常工作 ✅
> 点击结束后 → 再次点击键盘录音键 → 键盘显示录音标志（UI 状态正确） → **但 App 端未实际触发录音** → 无法转译 ❌

---

## 1. 构建信息

- **Worktree**: `/Users/xianggui/.openclaw/workspace/Echo/.claude/worktrees/loving-ardinghelli`
- **Branch**: `claude/loving-ardinghelli`
- **所有更改均未 commit** — 全部在 working directory 中
- **物理设备**: iPhone 15 Pro Max, Device ID: `D66DE9A7-41BF-5F89-B1F4-B9B990912BC0`
- **正确的 DerivedData**: `Echo-fpgfwrpwmnxpyedqgjmwhklbdexf`（worktree 专用）
- **Build 命令**: `xcodebuild build -project Echo.xcodeproj -scheme Echo -destination 'id=00008130-000A54A92E91001C'`
- **Install 命令**: `xcrun devicectl device install app --device D66DE9A7-41BF-5F89-B1F4-B9B990912BC0 "/Users/xianggui/Library/Developer/Xcode/DerivedData/Echo-fpgfwrpwmnxpyedqgjmwhklbdexf/Build/Products/Debug-iphoneos/EchoApp.app"`
- **Launch 命令**: `xcrun devicectl device process launch --device D66DE9A7-41BF-5F89-B1F4-B9B990912BC0 com.xianggui.echo.app`

> **注意**: 有多个 DerivedData 目录存在，必须使用 `Echo-fpgfwrpwmnxpyedqgjmwhklbdexf` 而非旧的 `Echo-gcyturxmeouzdydfabugvdpomfjy`（后者包含 2/25 的旧构建产物）。

---

## 2. 新建文件清单

| 文件 | 位置 | 说明 |
|------|------|------|
| `DarwinNotificationCenter.swift` | `Packages/EchoCore/.../Settings/` | 跨进程 Darwin 通知，5 种通知类型 |
| `ASRProviderResolver.swift` | `Packages/EchoCore/.../ASR/` | 从 VoiceRecordingViewModel 提取的 provider 解析逻辑 |
| `BackgroundDictationService.swift` | `Packages/EchoCore/.../Audio/` | 后台录音核心服务 |
| `BackgroundDictationOverlay.swift` | `iOS/EchoApp/Views/` | 主 App 内录音状态浮层 |

## 3. 修改文件清单

| 文件 | 改动概要 |
|------|----------|
| `AppGroupBridge.swift` | +DictationState enum, +StreamingPartial struct, +6 new IPC keys, +7 new methods |
| `AudioCaptureService.swift` | +`stopRecording(keepSessionActive:)`, +`idleEngine()`, +`resumeRecording()`, +`isEngineRunning`, +`configureForBackgroundRecording()`, +`deactivateAudioSession()` |
| `Info.plist` (iOS) | +`UIBackgroundModes: audio` |
| `EchoApp.swift` | +`@StateObject backgroundDictation`, +`.environmentObject()`, +`.onAppear { activate() }` |
| `MainView.swift` | +`@EnvironmentObject backgroundDictation`, +BackgroundDictationOverlay, voice 路由简化 |
| `KeyboardView.swift` | KeyboardTopBar 条件 voice 按钮: Button(Darwin) vs Link(URL) |
| `KeyboardViewController.swift` | +Darwin 观察, +增量文字注入, +心跳检查, +KeyboardState 新属性 |
| `Echo.xcodeproj/project.pbxproj` | +BackgroundDictationOverlay.swift 文件引用 |

---

## 4. 架构详解

### 4.1 通信协议

```
Darwin Notifications (信号，无 payload):
  dictationStart         键盘 → App    "开始录音"
  dictationStop          键盘 → App    "停止录音"
  transcriptionReady     App → 键盘    "有新的转写文字"
  heartbeat              App → 键盘    "App 后台还活着" (每 2s)
  stateChanged           App → 键盘    "录音状态已改变"

AppGroupBridge (shared UserDefaults, 携带数据):
  streamingText          String        当前 partial 文字
  streamingSequence      Int           单调递增序号 (防重复)
  streamingIsFinal       Bool          是否为最终结果
  dictationSessionId     String        会话 ID
  dictationState         String        idle/recording/transcribing/finalizing/error
  heartbeatTimestamp     TimeInterval  心跳时间戳
```

### 4.2 BackgroundDictationService 状态机

```
                activate()
                    │
                    ▼
    ┌───────────── IDLE ◄──────────────┐
    │               │                   │
    │  Darwin .dictationStart           │
    │               │                   │
    │               ▼                   │
    │          RECORDING ──────────────►│  (stopDictation)
    │               │                   │
    │     partial results               │
    │               │                   │
    │               ▼                   │
    │         TRANSCRIBING ────────────►│
    │                                   │
    │          FINALIZING ─────────────►│
    │                                   │
    └───── ERROR ──────────────────────►┘
              (auto-dismiss 5s)
```

### 4.3 音频引擎生命周期（最新修复）

```
performStartDictation():
  audioService 存在且 engine running?
    YES → resumeRecording() (swap noop tap → processing tap) [快速路径]
    NO  → new AudioCaptureService() → requestPermission() → startRecording() [完整路径]

performStopDictation():
  audioService?.idleEngine()   ← 安装 noop tap，引擎保持运行
  不 nil 掉 audioService       ← 保持引擎活跃，防止 iOS 挂起 App
  currentProvider = nil
  startIdleTimeout()           ← 5 分钟后才 stopRecording + nil audioService

cancelAllTasks() / deactivate():
  audioService?.stopRecording() → 完全停止引擎
  audioService = nil
```

### 4.4 键盘增量文字注入

```swift
// KeyboardViewController.handleStreamingPartialReady()
1. bridge.readStreamingPartial() → (text, sequence, isFinal, sessionId)
2. Skip if sequence <= lastInsertedSequence (防重复)
3. deleteBackward() × lastInsertedTextLength (删除上一次 partial)
4. insertText(newText)
5. lastInsertedTextLength = newText.count
6. If isFinal: reset all tracking state
```

### 4.5 键盘 Voice 按钮条件逻辑

```
KeyboardTopBar:
  if isBackgroundAlive (heartbeat < 6s):
    → Button: 发送 Darwin .dictationStart/.dictationStop (无跳转)
  else:
    → Link(echo://voice): 打开主 App (首次或 App 被杀后)
```

---

## 5. 已修复的 Bug

### 5.1 AVAudioSession 冲突 (OSStatus 560557684)
- **现象**: 跳转到 App 后显示 "Error: Failed to configure audio: OSStatus error 560557684"
- **原因**: MainView 的 `onOpenURL` 同时打开 VoiceRecordingView sheet 和调用 `backgroundDictation.startDictation()`，两者同时配置 AVAudioSession 冲突
- **修复**: 移除 `onOpenURL` 中的 `backgroundDictation.startDictation()` 调用，voice 路由只设置 `deepLink = .voice`

### 5.2 configureForBackgroundRecording 导致崩溃
- **现象**: 同样的 OSStatus 560557684
- **原因**: BackgroundDictationService 在 `performStartDictation()` 中先调 `configureForBackgroundRecording()` 再调 `startRecording()`，session 状态冲突
- **修复**: 移除单独的 `configureForBackgroundRecording()` 调用，使用 `startRecording()` 内置的 session 配置路径（与 VoiceRecordingView 一致），之后非致命地尝试 `.mixWithOthers` 升级

### 5.3 Error Overlay 持续显示
- **修复**: 添加 5 秒自动消除 — 如果 5 秒后仍在 `.error` 状态，自动转为 `.idle`

### 5.4 DerivedData 路径错误
- **现象**: 安装后 App 显示旧 UI，所有新功能消失
- **原因**: xcodebuild 为 worktree 创建了新的 DerivedData 目录 `Echo-fpgfwrpwmnxpyedqgjmwhklbdexf`，但 install 命令使用了旧目录 `Echo-gcyturxmeouzdydfabugvdpomfjy`
- **修复**: 使用正确的 DerivedData 路径安装

### 5.5 BackgroundDictationOverlay 未加入 Xcode 项目
- **现象**: 编译时找不到 BackgroundDictationOverlay
- **原因**: 新建 Swift 文件未添加到 pbxproj
- **修复**: 手动添加 PBXFileReference、PBXBuildFile、PBXGroup、PBXSourcesBuildPhase 条目

---

## 6. 当前未修复 Bug (CRITICAL — 下一步待修)

### 6.1 再次录音失败：键盘显示录音状态但 App 未实际触发录音

**复现步骤:**
1. 打开 Echo App
2. 切到其他 App 的输入框，打开 Echo 键盘
3. 点击键盘麦克风 → 跳转到 Echo App → 看到录音界面
4. 手动切回输入框 → 键盘显示录音状态 → 实时转译正常 ✅
5. 点击键盘录音按钮停止
6. **再次点击键盘录音按钮** → 键盘 UI 显示录音标志 → **但 App 端没有实际开始录音** → 无转译结果 ❌

**分析:**

键盘侧行为正确：
- 心跳检测通过 → `isBackgroundDictationAlive = true` → 显示 Button 模式
- 点击 Button → 发送 Darwin `.dictationStart`

问题在 App 侧：收到 Darwin 通知后 `performStartDictation()` 可能失败。可能原因：

1. **AsyncStream 复用问题**: `AudioCaptureService.audioChunks` 是 init 时创建的 `AsyncStream`。第一次 `recordingTask` 被取消后，新的 `for await chunk in audio.audioChunks` 可能无法从同一个 stream 获取新的 chunks。这是 Swift `AsyncStream` 的单消费者限制 — 虽然理论上新 iterator 应该能继续消费，但实际行为可能有问题。

2. **idleEngine() 后 resumeRecording() 的 tap 冲突**: 调用 `idleEngine()` 安装了 noop tap，`resumeRecording()` 先 `removeTap` 再 `installTap`，但可能在 removeTap 和 installTap 之间的状态不一致导致问题。

3. **Darwin 通知未送达后台 App**: 尽管 `idleEngine()` 保持引擎运行，iOS 可能仍然不认为有 "active audio processing"（noop tap 不产生实际音频数据）。如果 iOS 挂起了 App，Darwin 通知就不会被处理。

4. **debounceCheck() 时序**: `handleDictationStopRequest()` 设置了 `lastToggleTime`，如果用户在 500ms 内再次点击，会被 debounce 过滤。

**建议的调试方向:**
- 在 `handleDictationStartRequest()` 入口添加可观察的日志（写入 AppGroupBridge），从键盘侧读取确认是否收到通知
- 在 `performStartDictation()` 的每个 guard/early-return 处添加日志
- 检查 `audioService?.isEngineRunning` 在第二次调用时的值
- 考虑：是否 `AsyncStream` 需要在 `resumeRecording()` 时重建（而不是复用 init 时创建的那个）

**最可能的根因**: `AsyncStream` 复用问题。第一个 `recordingTask` 取消后，`audioChunks` 的内部 iterator 状态可能已经被标记为完成。`resumeRecording()` 虽然重新安装了 processing tap（audioContinuation.yield 被调用），但新的 `for await` 可能创建不了有效的新 iterator。

**建议的修复方向**: 让 `AudioCaptureService` 支持 "reset stream" — 在 `resumeRecording()` 时创建新的 `AsyncStream` + `Continuation`，这样新的 `recordingTask` 可以从全新的 stream 消费。

---

## 7. 文件详细参考

### DarwinNotificationCenter.swift
```swift
public final class DarwinNotificationCenter: @unchecked Sendable {
    public static let shared = DarwinNotificationCenter()
    public enum Name: String, Sendable, CaseIterable {
        case dictationStart = "com.echo.dictation.start"
        case dictationStop = "com.echo.dictation.stop"
        case transcriptionReady = "com.echo.transcription.ready"
        case heartbeat = "com.echo.dictation.heartbeat"
        case stateChanged = "com.echo.dictation.stateChanged"
    }
    // CFNotificationSuspensionBehaviorDeliverImmediately for background delivery
    // NSLock-protected handler registry
    // ObservationToken RAII pattern
}
```

### ASRProviderResolver.swift
```swift
public struct ASRProviderResolver: Sendable {
    // Convenience init with @MainActor (accesses EchoAuthSession properties)
    @MainActor
    public init(settings: AppSettings, keyStore: SecureKeyStore, authSession: EchoAuthSession)

    // Direct init (no MainActor requirement)
    public init(settings: AppSettings, keyStore: SecureKeyStore, accessToken: String, backendBaseURL: String)

    public func resolve() -> ASRProviderResolution?
    // Dual mode: backendProxy / clientDirect, with multi-level fallback
}
```

### BackgroundDictationService.swift — Key State Management
```swift
// After stop: engine transitions to idle noop tap
private func performStopDictation() async {
    recordingTask?.cancel()
    audioService?.idleEngine()  // noop tap, engine keeps running
    // provider.stopStreaming() → final result
    currentProvider = nil       // release provider
    // audioService NOT nil'd   // keep engine alive
    startIdleTimeout()          // 5 min → full shutdown
}

// On restart: reuse engine if still running
private func performStartDictation() async {
    if let existing = audioService, existing.isEngineRunning {
        try audio.resumeRecording()  // swap noop → processing tap
    } else {
        // full fresh start path
    }
}
```

### KeyboardViewController.swift — Streaming Text Injection
```swift
private func handleStreamingPartialReady() {
    let bridge = AppGroupBridge()
    guard let partial = bridge.readStreamingPartial() else { return }
    guard partial.sequence > lastInsertedSequence else { return }

    // New session detection
    if partial.sessionId != currentStreamSessionId {
        currentStreamSessionId = partial.sessionId
        lastInsertedSequence = -1
        lastInsertedTextLength = 0
    }

    // Incremental: delete old → insert new
    if lastInsertedTextLength > 0 {
        for _ in 0..<lastInsertedTextLength {
            textDocumentProxy.deleteBackward()
        }
    }
    textDocumentProxy.insertText(newText)
    lastInsertedTextLength = newText.count
    lastInsertedSequence = partial.sequence
}
```

---

## 8. 下一步 (给 CLI 端接手)

### 优先级 1: 修复再次录音失败 bug (Section 6.1)

1. **添加可观察日志**: 在 `handleDictationStartRequest()` / `performStartDictation()` 的关键点写入 AppGroupBridge 的 debug key，键盘侧可以读取并显示 toast，确认通知是否送达、哪一步失败

2. **AsyncStream 复用验证**: 写一个最小测试验证 `AsyncStream` 被 cancel 后能否被新的 `for await` 消费。如果不行，修改 `AudioCaptureService` 添加 `resetAudioStream()` 方法

3. **备选方案**: 如果 `idleEngine()` 不足以防止 iOS 挂起，考虑在 idle 期间播放极低音量的静音音频来保持 active audio output

### 优先级 2: VoiceRecordingView 复用 ASRProviderResolver
- VoiceRecordingView.swift 的 `resolveASRProvider()` (~140 行) 应改用 `ASRProviderResolver`
- 减少代码重复

### 优先级 3: Session 管理完善 (Plan Phase 4)
- App 被杀时清理 bridge 状态
- Audio interruption (电话来了) 处理
- 可配置 idle timeout (当前固定 5 分钟)

---

## 9. Evening Crisis: Session 4 Rewrite Destroyed Work (Feb 27 ~7:55 PM)

### What Happened
- Session 4 attempted a "plan-based re-implementation" after context compaction
- The rewrite overwrote 2 days of uncommitted work in the `loving-ardinghelli` worktree
- All Phase 1-3 changes (DarwinNotificationCenter, BackgroundDictationService, keyboard injection, etc.) were lost
- The worktree was later cleaned up, making direct recovery impossible

### Recovery Process
1. Identified `@v1` backup files in `~/.claude/file-history/` — byte-identical to commit `a082201`
2. Extracted pre-session baselines from JSONL transcripts (Session 2-4 `Read` tool results)
3. Built recovery script `/tmp/recover_sessions.py` to replay edits from JSONL
4. Successfully recovered 22 source files from session transcript history
5. Fixed post-recovery build errors:
   - Duplicate `CorrectionResult.swift` (removed from LLMCorrection/)
   - `AppSettings.swift` syntax errors (restored from git commit `7d8333f`)
   - Missing `apiCallMode` property in AppSettings
   - `BackgroundDictationService` API mismatches with recovered files
   - `MainView.swift` invalid `quickStartMode` parameter

### Result
- Switched to `feature/rebuild-from-0225` branch
- Build succeeded at ~9:46 PM
- Deployed to iPhone and verified working
- Committed as `f86cebc`

### Key Lesson
**Never do large-scale rewrites without committing first.** Context compaction causes the agent to lose awareness of prior uncommitted changes, leading to destructive overwrites.

---

*Last updated: 2026-02-27 22:00*
*Session: multiple recovery sessions*
*Build: succeeded | Deployed to iPhone*
*Git: committed on feature/rebuild-from-0225 (f86cebc)*
